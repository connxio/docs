---
sidebar_position: 41
---

import ThemedImage from '@theme/ThemedImage';
import useBaseUrl from '@docusaurus/useBaseUrl';

# Scripts

Scripts are an alternative way of transforming data in Connxio. Instead of uploading code components, you can write JavaScript directly in the Connxio portal. This is a quick and easy way to do small transformations without having to create, test, and upload code components. You have full access to the message content and metadata, and can use standard JavaScript libraries to manipulate the data.

:::info Security
For security reasons, scripts run in a sandboxed environment with limited access to system resources. This means that certain operations, such as file I/O, are not available. The `fetch` API is available for making HTTP requests, but other network operations are restricted.
:::

## Creating a script

To create a script, add a new transformation shape to your integration and select "Script" as the transformation type.

<div style={{maxWidth: '800px'}}>
  <ThemedImage
    alt="add script shape"
    style={{boxShadow: 'none'}}
    sources={{
      light: useBaseUrl('/img/docs/transformations/script-light.webp'),
      dark: useBaseUrl('/img/docs/transformations/script-dark.webp#dark-only'),
    }}
  />
</div>

You will then be presented with a code editor where you can write your JavaScript code. From here you can make use of the event object which contains the message content and metadata. An example script is provided by default, which you can modify to suit your needs.

```javascript
/**.
* Handler that will be called during the execution of the script.
*
* @param {TransformationEvent) event - Contains the file content and metadata about the file.
* @returns {TransformationEvent} Return the modified event.
*/
const execute = (event) => <
// Example modification:
  const myobj = JSON.parse(event.content):
  myObj newField = "This is a new field added to the JSON object.";
  event.content = JSON.stringify(myObj):
  return event;
}
```

<div style={{maxWidth: '800px'}}>
  <ThemedImage
    alt="configure script shape"
    style={{boxShadow: 'none'}}
    sources={{
      light: useBaseUrl('/img/docs/transformations/configure-script-light.webp'),
      dark: useBaseUrl('/img/docs/transformations/configure-script-dark.webp#dark-only'),
    }}
  />
</div>

When you are done writing your script, click "Done" and save the integration. The script will now be executed whenever a message passes through the transformation shape in your integration.

### Testing a script

Included in the script editor is a "Test Script" feature that allows you to test your script with sample data. This is useful for verifying that your script works as expected before deploying it in a live integration. You can provide a test input and metadata, and see the output generated by your script.

<div style={{maxWidth: '800px'}}>
  <ThemedImage
    alt="test script shape"
    style={{boxShadow: 'none'}}
    sources={{
      light: useBaseUrl('/img/docs/transformations/test-script-light.webp'),
      dark: useBaseUrl('/img/docs/transformations/test-script-dark.webp#dark-only'),
    }}
  />
</div>

Any errors in your script will be displayed in the errors section, allowing you to quickly identify and fix issues.

You can also make use of `console.log()` statements in your script to output debug information to the console. This can be helpful for troubleshooting and understanding the flow of your script. The logs are displayed in the "Logs" section of the test results and are ordered in the sequence they were called during script execution. When running the script in a live integration, all logs will be ignored for performance reasons.

## Dependencies

You can import external JavaScript modules in your scripts using ESM (ECMAScript Modules) syntax. Modules are automatically resolved from [jsDelivr](https://www.jsdelivr.com/), so you can import them by package name:

```javascript
import { cloneDeep } from "lodash-es";
```

:::warning Module compatibility

- Only modules with ESM builds are supported
- Module compatibility varies depending on the module's dependencies and implementation. Modules without external dependencies have the highest likelihood of working correctly in the sandboxed environment
- Adding a module import will increase the execution time of your script, so use them judiciously
  :::

### Example: XML to JSON transformation

```javascript
import { XMLParser } from "fast-xml-parser";

/**
 * @param {TransformationEvent} event - Contains the file content and metadata about the file.
 * @returns {TransformationEvent} Return the modified event.
 */
const execute = (event) => {
  const xmlString = event.content;
  // Create parser instance
  const parser = new XMLParser();
  // Parse XML
  const result = parser.parse(xmlString);
  const myObj = {
    id: result.Root.TheProperty.TheId,
  };
  event.content = JSON.stringify(myObj);
  return event;
};
```

<!-- ### Creating custom modules

You can publish your own reusable modules to npm and use them in your scripts. This is useful when you have transformation logic that you want to share across multiple integrations or with your team.

#### Module structure

Create a standard JavaScript/TypeScript project with an ESM entry point:

```bash
my-connxio-module/
├── package.json
├── src/
│   └── index.js
└── dist/
    └── index.js  (compiled output)
```

Your main module file should export the functions you want to use:

```javascript
// src/index.js - Named exports (recommended for clarity)
export function validateEmail(email) {
  return /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email);
}

export function sanitizeString(str) {
  return str.trim().toLowerCase();
}

// Or use a default export
export default {
  validateEmail,
  sanitizeString,
};
```

#### Package.json configuration

Ensure your `package.json` is configured for ESM:

```json
{
  "name": "@yourorg/my-connxio-module",
  "version": "1.0.0",
  "description": "Custom module for Connxio scripts",
  "type": "module",
  "main": "dist/index.js",
  "exports": {
    ".": "./dist/index.js"
  },
  "files": ["dist"]
}
```

The `"type": "module"` field is essential—it tells npm that your module uses ESM syntax.

:::warning No external npm dependencies

Custom modules **cannot have external npm dependencies**. Your module must be completely self-contained with all functionality implemented in the module itself. If you need to use a third-party library, import it directly in your script instead of bundling it with your custom module.

:::

#### Sandboxing constraints

When creating custom modules, keep in mind the following restrictions of the sandboxed environment:

- **No Node.js APIs** - No `fs`, `path`, `http`, `crypto` modules
- **No native modules** - Your module cannot use compiled C/C++ extensions
- **No external network calls** (except `fetch` API) - No direct socket connections
- **No external npm dependencies** - Your module must be completely self-contained

Modules are limited to pure JavaScript with no external dependencies.

#### Testing locally

Before publishing, test your module locally by importing it in Node.js:

```javascript
// test.js
import { validateEmail, sanitizeString } from "./dist/index.js";

const result = validateEmail("user@example.com");
console.log(result); // true
```

You can also build and test it as if it were imported from jsDelivr by using a local HTTP server or bundler.

#### Making your module accessible

You have two options for making your custom module accessible:

**Option 1: Publish to npm**

Publish your module to npm, and it will be automatically available for import:

```javascript
import { validateEmail, sanitizeString } from "@yourorg/my-connxio-module";
```

**Option 2: Self-host the .js file**

You can also host the compiled `.js` file yourself on any publicly accessible CDN or web server and import it directly:

```javascript
import {
  validateEmail,
  sanitizeString,
} from "https://my-api-or-cdn.com/validateemail.js";
```

This gives you full control over versioning and deployment.

#### Using your custom module

Once your module is published to npm or self-hosted, import it in your scripts:

```javascript
// Named imports from npm
import { validateEmail, sanitizeString } from "@yourorg/my-connxio-module";

/**
 * @param {TransformationEvent} event - Contains the file content and metadata about the file.
 * @returns {TransformationEvent} Return the modified event.
 */
const execute = (event) => {
  const data = JSON.parse(event.content);

  if (!validateEmail(data.email)) {
    throw new Error("Error|Invalid email address");
  }

  data.name = sanitizeString(data.name);
  event.content = JSON.stringify(data);
  return event;
};
```

Or with a self-hosted module:

```javascript
import utils from "https://my-api-or-cdn.com/utils.js";

/**
 * @param {TransformationEvent} event - Contains the file content and metadata about the file.
 * @returns {TransformationEvent} Return the modified event.
 */
const execute = (event) => {
  const data = JSON.parse(event.content);

  if (!utils.validateEmail(data.email)) {
    throw new Error("Error|Invalid email address");
  }

  data.name = utils.sanitizeString(data.name);
  event.content = JSON.stringify(data);
  return event;
};
```

#### Dependency considerations

- **Avoid heavy dependencies** - Each import increases script execution time
- **Check ESM compatibility** - Ensure all dependencies provide ESM builds
- **Simple is better** - Modules without external dependencies are more reliable in the sandboxed environment
- **Specify versions** - Always pin your module version for consistency

```javascript
// Good - specific version from npm
import { myFunc } from "@yourorg/my-module@1.2.3";

// Also good - self-hosted with version
import { myFunc } from "https://my-cdn.com/my-module/v1.2.3/index.js";
``` -->

## Termination

You can terminate a message by throwing an <code>Error</code> from your script. Connxio will check the error message for specific code words to determine how to handle the termination. For any other exceptions, the message will be terminated with an error log level.

You can supply the termination error message with a set of code words to influence the behavior of the termination process. The pipeline is always terminated but the code word controls the logging associated with it. You supply these code words in the following way:

```csharp
//The code word before the pipe (|) is used to select the action while the text after the pipe is used as the log event message sent via the [logging events functionality](/integrations/logging).
throw new Error("Warning|Integration terminated with warning");
```

We support the following options on termination:
| Code word | Action |
|---|---|
| Success| | The termination is logged as a success with the minimum log level.|
| Warning | The termination is logged as a warning with the minimum log level. |
| Error | The termination is logged as an error with the none log level. |
| Loglevel:None | The termination is logged with the terminated status but with the none log level instead of the default minimum level.|
| Loglevel:Never| | The termination is not logged at all.|
| _Default behavior_ | The integration is not considered terminated by the user and normal error handling takes over. |
